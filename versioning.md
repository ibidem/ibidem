Versioning
==========

The following describes the versioning conventions. 

In short: Versioning is strict and technical. No exceptions.

No-Version Rule
---------------

Anything that doesn't meet minimum requirements and is not already on a version
is considered Alpha (ie. `0.0`). This does not change until the first version is
created. Alpha's do not get versioned on hotfixes, bugfixes, etc. It's permanent
0.0 until it becomes stable. Alpha's don't have any set branch naming 
convention; there is usually no 0.0 branch.

There is no beta, etc. The first version after the "alpha" state is stable/v1.0

Stable Release
--------------

Stable versions are released as branches. The branches have the name
`stable/vX.Y`. Where X and Y can go up to any positive value; X >= 1, and 
Y >= 0. The branches are also tagged apropriatly.

For a module to be considered stable the following conditions need to be met:

 * all behaviour defined by the module needs to be defined in behaviour tests
 * all tests must pass
 * all functions and classes and associated behaviour and use cases must be
 documented (autogenerated docs are not acceptable and do not count at all)
 * all issues must be resolved, all feature requests answered
 * relationships with other modules must be accounted for

Documentation needs to be available in a printable format. As long as a 
printable version of the documentation exists, anything else such as a website
showing it being updated, etc is not important.

When moving from the Alpha stage to the initial version the number `1.0` is 
assigned, thus the `stable/v1.0` branch is created and the source is also 
tagged `v1.0`

Revisions/Hotfixes are documented as `v1.0r3` ("version 1.0 revision 3"). They 
do not affect the branch name conventions, but do reflect in tag names.

If errors are found in a version, eg. `stable/v1.0`. Then a branch `unstable/v1.0`
is created from said version and the `stable/v1.0` is removed from the server. 
This may be ommited if a revision is rolled out in a timely manner. Where timely
is considered 1 hour or less from the time the problem is noticed. When v1.0 
becomes stable again `stable/v1.0` is recreated and `unstable/v1.0` is removed.

If for whatever reason you need to get v1.0 consistently with out worrying about
it being in stable or unstable state, you use the tags instead.

Even if all conditions are met, a version may be posponed. Reasons for 
postponing a version may include practical considerations such as using it more 
before shipping it out (to avoid unnecesary changes to changes). This applies to 
the move from alpha state to v1.0 as well.

Version Numbers
---------------

When a new feature is added, which is to say behaviour tests are written, 
documentation is made, it's all implemented and everyone is happy with how it
works, the version number is incremented by the following rules:

 * given version number vX.Y
 * Y goes up by 1 when anything is added, where the value of Y is the previous
 stable version in the series
 * X goes up by 1 and Y is reset, when backporting is not feasible

Backporting is not feasible when a change causes an irrecoverable invalidation
of past behaviour; how major it is is irrelevant.

The policy on any change to what is technically existing functionality is that
all relevant behaviour tests are moved to the (designated) legacy module along
with the deprecated code. It is prefered to avoid breaking the behaviour as much
as possible (re-inventing names, duplicating api, etc not being a problem), eg.
it's prefered to create a replacement for a Cache class and call it Stash then
to break the existing Cache class (as an example).

There is only one exception. Because classes are inevatably moved, they're 
namespace changes, so updating classes that extend explicitly a class is 
considered an edge case, because it is easily avoided, and the responsibility 
falls on the one updating.

Sometimes the behaviour has to change and interoperability is simply not 
possible, when this happens the X version is incremented and Y reset. So `v1.3` 
will go to `v1.4` regardless of how major the features are, but will go to 
`v2.0` regardless of how minor the change, if the change can't be moved to legacy.

Anyone who whishes to only use the current latest version of the code is free to
simply ignore the legacy modules.

The reason for supporting backporting is simple: minor tweaks and optimizations
always come up, but it's rarely if ever worth it to refactor a giant project
for their sake. Similarly everyone generally wants to get the latest version
as quickly as possible, by supporting backporting upgrading can be instant so 
long as X wasn't changed. This allows for security bugs to be fix'ed imediatly
regardless of the size of the project. The development team can then go in and
refactor the code to support the latest changes and subsequently remove the 
legacy modules (again) should they wish to run only the latest iterations on
features.

Release Schedule
----------------

It's ready when it's ready.

This means a new version can come every hour or take an entire year. All 
features are weighted and how and when is simply determined on a per feature
basis.

That being said, quick releases and small changes are prefered over monolithic 
ones, since they give the most benefit overall.

If you wish for a 6 month cycle just come by every 6 months, and you have your
6 month cycle.
